# Azure DevOps Pipeline for PrepMyCert Flask Application
# This pipeline builds, tests, and deploys the application to Azure App Service

trigger:
  - main
  - develop

pool:
  vmImage: 'ubuntu-latest'

variables:
  # Application settings
  pythonVersion: '3.12'
  appName: 'prepmycert-app'
  resourceGroup: 'prepmycert-rg'
  
  # Build configuration
  buildConfiguration: 'Release'
  
stages:
- stage: Build
  displayName: 'Build Stage'
  jobs:
  - job: BuildJob
    displayName: 'Build and Test Application'
    steps:
    
    # Use specific Python version
    - task: UsePythonVersion@0
      displayName: 'Use Python $(pythonVersion)'
      inputs:
        versionSpec: '$(pythonVersion)'
        addToPath: true
    
    # Cache pip dependencies for faster builds
    - task: Cache@2
      displayName: 'Cache pip packages'
      inputs:
        key: 'python | "$(Agent.OS)" | requirements.txt'
        restoreKeys: |
          python | "$(Agent.OS)"
        path: $(PIP_CACHE_DIR)
    
    # Install dependencies
    - script: |
        python -m venv venv
        source venv/bin/activate
        python -m pip install --upgrade pip
        pip install -r requirements.txt
      displayName: 'Install dependencies'
    
    # Run security checks (optional)
    - script: |
        source venv/bin/activate
        pip install safety bandit
        safety check
        bandit -r . -f json -o bandit-report.json || true
      displayName: 'Security checks'
      continueOnError: true
    
    # Run tests if they exist
    - script: |
        source venv/bin/activate
        if [ -f "test_requirements.txt" ]; then
          pip install -r test_requirements.txt
        fi
        if [ -d "tests" ]; then
          python -m pytest tests/ --junitxml=test-results.xml --cov=. --cov-report=xml
        else
          echo "No tests directory found, skipping tests"
        fi
      displayName: 'Run tests'
      continueOnError: true
    
    # Publish test results
    - task: PublishTestResults@2
      displayName: 'Publish test results'
      inputs:
        testResultsFiles: 'test-results.xml'
        testRunTitle: 'Python Tests'
      condition: succeededOrFailed()
    
    # Publish code coverage
    - task: PublishCodeCoverageResults@1
      displayName: 'Publish code coverage'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: 'coverage.xml'
      condition: succeededOrFailed()
    
    # Create deployment package
    - task: ArchiveFiles@2
      displayName: 'Archive application files'
      inputs:
        rootFolderOrFile: '$(System.DefaultWorkingDirectory)'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip'
        replaceExistingArchive: true
        excludePaths: |
          venv/
          .git/
          .pytest_cache/
          __pycache__/
          *.pyc
          .env
          .vscode/
          tests/
    
    # Publish build artifact
    - task: PublishBuildArtifacts@1
      displayName: 'Publish build artifacts'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)'
        artifactName: 'drop'
        publishLocation: 'Container'

- stage: Deploy
  displayName: 'Deploy Stage'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployToProduction
    displayName: 'Deploy to Azure App Service'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          
          # Download build artifacts
          - task: DownloadBuildArtifacts@0
            displayName: 'Download build artifacts'
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: 'drop'
              downloadPath: '$(System.ArtifactsDirectory)'
          
          # Deploy to Azure App Service
          - task: AzureWebApp@1
            displayName: 'Deploy to Azure App Service'
            inputs:
              azureSubscription: 'azure-service-connection'  # Replace with your service connection name
              appType: 'webAppLinux'
              appName: '$(appName)'
              package: '$(System.ArtifactsDirectory)/drop/$(Build.BuildId).zip'
              runtimeStack: 'PYTHON|3.12'
              startUpCommand: 'bash startup.sh'
          
          # Health check after deployment
          - task: PowerShell@2
            displayName: 'Application health check'
            inputs:
              targetType: 'inline'
              script: |
                $uri = "https://$(appName).azurewebsites.net/health"
                $maxRetries = 10
                $retryCount = 0
                
                do {
                    try {
                        $response = Invoke-WebRequest -Uri $uri -TimeoutSec 30
                        if ($response.StatusCode -eq 200) {
                            Write-Host "‚úÖ Application health check passed"
                            exit 0
                        }
                    }
                    catch {
                        Write-Host "‚è≥ Health check attempt $($retryCount + 1) failed: $($_.Exception.Message)"
                    }
                    
                    $retryCount++
                    Start-Sleep -Seconds 30
                    
                } while ($retryCount -lt $maxRetries)
                
                Write-Host "‚ùå Application health check failed after $maxRetries attempts"
                exit 1
            continueOnError: false
          
          # Run post-deployment tasks
          - task: AzureCLI@2
            displayName: 'Post-deployment tasks'
            inputs:
              azureSubscription: 'azure-service-connection'  # Replace with your service connection name
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Running post-deployment tasks..."
                
                # Warm up the application
                echo "üî• Warming up application..."
                curl -f "https://$(appName).azurewebsites.net/" || echo "Warmup request failed"
                
                # Check application insights connection
                echo "üìä Verifying Application Insights..."
                az webapp config appsettings list \
                  --resource-group $(resourceGroup) \
                  --name $(appName) \
                  --query "[?name=='APPINSIGHTS_INSTRUMENTATIONKEY'].value" \
                  --output tsv
                
                echo "‚úÖ Post-deployment tasks completed"

- stage: DeployStaging
  displayName: 'Deploy to Staging'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
  jobs:
  - deployment: DeployToStaging
    displayName: 'Deploy to Staging Environment'
    environment: 'staging'
    variables:
      appName: 'prepmycert-staging'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadBuildArtifacts@0
            displayName: 'Download build artifacts'
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: 'drop'
              downloadPath: '$(System.ArtifactsDirectory)'
          
          - task: AzureWebApp@1
            displayName: 'Deploy to Staging App Service'
            inputs:
              azureSubscription: 'azure-service-connection'
              appType: 'webAppLinux'
              appName: '$(appName)'
              package: '$(System.ArtifactsDirectory)/drop/$(Build.BuildId).zip'
              runtimeStack: 'PYTHON|3.12'
              startUpCommand: 'bash startup.sh'